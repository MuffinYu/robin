---
title: 算法基础(2)——二叉树
date: 2019-11-02 14:41:22
tags:
---

### 定义

二叉树（Binary Tree），是 n (n >= 0) 个节点的有限集合，该集合或者为空集（空二叉树），或者由一个根节点和两颗互不相交的、分别称为根节点的左子树和右子树的二叉树组成；

<!-- more  -->

### 特点

- 1. 每个节点最多有两颗子树；所以二叉树中不存在度大于2的节点。是最多有两颗子树，可以没有子树或者只有一棵子树，有一棵的时候区分子树是左子树还是右子树。

- 2. 左子树和右子树是有顺序的，次序不能任意颠倒。

- 3. 即使某个节点只有一棵子树，也需要区分是左子树还是右子树。

### 性质

#### 性质1

在二叉树的第 i 层，至多有 2<sup>i-1</sup> 个节点；

#### 性质2

深度为 k 的二叉树至多有 2<sup>k</sup> - 1个结点 (k>= 1)；

#### 性质3

对任何一棵二叉树 T，如果其终端结点数为n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1；

#### 性质4

具有 n 个结点的完全二叉树的深度为 [log<sub>2</sub>n] + 1 ([x] 表示不大于 x 的最大整数)。

#### 性质5

如果对一棵有 n 个结点的完全二叉树(其深度为 [log<sub>2</sub>n]+1) 的结点按层序编号(从第 1 层到第 [log<sub>2</sub>n]+1 层，每层从左到右) ，对任一结点 i (1 <= i <= n) 有:

1. 如果 i=1 ，则结点 i 是二叉树的根，无双亲；如果i> 1，则其双亲是结点 [i/2]。

2. 如果 2i > n ，则结点 i 无左孩子(结点 i 为叶子结点)；否则其左孩子是结点 2i。

3. 如果 2i+1> n，则结点 i 无右孩子；否则其右孩子是结点 2i + 1。

### 二叉树代码定义和构建

1. 定义

```java
public class BinaryTree {

  @Getter
  @Setter
  private Object data;

  @Getter
  @Setter
  private BinaryTree left;

  @Getter
  @Setter
  private BinaryTree right;

  @Getter
  @Setter
  private BinaryTree root;


  public BinaryTree(BinaryTree left, BinaryTree right, Object data) {
    super();
    this.left = left;
    this.right = right;
    this.data = data;
  }
  public BinaryTree(Object data) {
    this(null, null, data);
  }
  public BinaryTree() {
    super();
  }

}
```

2. 构建 

```java
public void create(Object[] objs) {
  ArrayList<BinaryTree> datas = new ArrayList<BinaryTree>();
  for (Object obj:objs) {
    datas.add(new BinaryTree(obj));
  }
  root = datas.get(0);
  int loopCount = (int) Math.floor(objs.length / 2);
  for (int i = 0; i < loopCount; i++) {
    datas.get(i).left = datas.get(i * 2 + 1);
    // 避免偶数的时候越界
    if (i * 2 + 2 < datas.size()){
      datas.get(i).right = datas.get(i * 2 + 2);
    }
  }
}
```

给定一个数组，该方法以这个数组为层序遍历的结果，构建二叉树；


### 二叉树遍历

遍历可以分为四种遍历方式：前序遍历、中序遍历、后序遍历和层序遍历，最常见的是前三种，根据实现的方式，可以分为迭代实现和循环实现，递归实现比较简单，也好理解，循环实现则较难理解；

1. 前序遍历的迭代实现和循环实现
  前序遍历：任意子树，先遍历根节点，再遍历左子树，最后遍历右子树；
```java
/**
  * 递归实现
  * 前序遍历
  * @param root
  */
public void preorder(BinaryTree root) {
  if (root != null) {
    System.out.print(root.getData()+" ");
    preorder(root.getLeft());
    preorder(root.getRight());
  }
}
 /**
  * 循环实现
  * 前序遍历
  */
public void preorderloop(BinaryTree root) {
  if (root != null) {
    Stack<BinaryTree> stack = new Stack<BinaryTree>();
    //栈不为空时，或者p不为空时循环
    while (root != null || !stack.isEmpty()) {
      if (root != null) {
        System.out.print(root.getData()+ " ");
        stack.push(root);
        root = root.getLeft();
      } else {
        root = stack.pop().getRight();
      }
    }
  }
}
```
2. 中序遍历的迭代实现和循环实现
  中序遍历：任意子树，先遍历左子树，再遍历根节点，最后遍历右子树；
```java
/**
   * 递归实现
   * 中序遍历
   * @param root
   */
  public void midorder(BinaryTree root) {
    if (root != null) {
      midorder(root.getLeft());
      System.out.print(root.getData()+" ");
      midorder(root.getRight());
    }
  }
 /**
   * 循环实现
   * 中序遍历
   * @param root
   */
  public void midorderloop(BinaryTree root) {
    if (root != null) {
      Stack<BinaryTree> stack = new Stack<BinaryTree>();
      while (root != null || !stack.isEmpty()) {
        if (root != null) {
          stack.push(root);
          root = root.getLeft();
        } else {
          root = stack.pop();
          System.out.print(root.getData()+ " ");
          root = root.getRight();
        }
      }
    }
  }
```

3. 后序遍历的迭代实现和循环实现
  后序遍历：任意子树，先遍历左子树，再遍历右子树，最后遍历根节点；

```java
/**
   * 递归实现
   * 后序遍历
   * @param root
   */
  public void postorder(BinaryTree root) {
    if (root != null) {
      postorder(root.getLeft());
      postorder(root.getRight());
      System.out.print(root.getData()+" ");
    }
  }
/**
   * 循环实现
   * 后序遍历
   * @param root
   */
  public void postorderloop(BinaryTree root) {
    if (root != null) {
      Stack<BinaryTree> stack = new Stack<BinaryTree>();
      Stack<Integer> tag = new Stack<Integer>();

      while (root != null || !stack.isEmpty()) {
        if (root != null) {
          stack.push(root);
          //第一次访问
          tag.push(1);
          root = root.getLeft();
        } else {
          if (tag.peek() == 2) {
            System.out.print(stack.pop().getData() + " ");
            tag.pop();
          } else {
            tag.pop();
            //第二次访问
            tag.push(2);
            root = stack.peek().getRight();
          }
        }
      }
    }
  }
```

### 特殊二叉树

### 1. 斜树 

**所有的节点都只有左子树的二叉树叫左斜树。所有节点只有右子树的二叉树叫右斜树。**

### 2. 满二叉树

**在一棵二叉树中，如果所有的分支节点都存在左子树和右子树，并且所有叶子节点都在同一层上，这样的二叉树又称为满二叉树。**

### 3. 完全二叉树

**对一颗具有n个节点的二叉树按层序编号，如果编号为 i (1 <= i <=n)的节点与同样深度的满二叉树中编号为 i 的节点在二叉树中的位置完全相同，则这颗二叉树称为完全二叉树。**